var _a, _b;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import axios from "axios";
import { isNodeLike } from "@azure/core-util";
const AXIOS_ERR_NETWORK = (_b = (_a = axios === null || axios === void 0 ? void 0 : axios.AxiosError) === null || _a === void 0 ? void 0 : _a.ERR_NETWORK) !== null && _b !== void 0 ? _b : "ERR_NETWORK";
/**
 * This class holds data for all cloud instances, and returns the specific data instance by parsing the dns suffix from a URL
 */
class CloudSettings {
    constructor() {
        var _a;
        this.METADATA_ENDPOINT = "/v1/rest/auth/metadata";
        this.defaultCloudInfo = {
            LoginEndpoint: (isNodeLike ? (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.AadAuthorityUri : undefined) || "https://login.microsoftonline.com",
            LoginMfaRequired: false,
            KustoClientAppId: "db662dc1-0cfe-4e1c-a843-19a68e65be58",
            KustoClientRedirectUri: "https://microsoft/kustoclient",
            KustoServiceResourceId: "https://kusto.kusto.windows.net",
            FirstPartyAuthorityUrl: "https://login.microsoftonline.com/f8cdef31-a31e-4b4a-93e4-5f571e91255a",
        };
        this.cloudCache = {};
        this.getFromCache = (kustoUri) => this.cloudCache[this.normalizeUrl(kustoUri)];
        this.deleteFromCache = (kustoUri) => delete this.cloudCache[this.normalizeUrl(kustoUri)];
    }
    writeToCache(url, info) {
        this.cloudCache[this.normalizeUrl(url)] = info !== null && info !== void 0 ? info : this.defaultCloudInfo;
    }
    async getCloudInfoForCluster(kustoUri) {
        var _a;
        kustoUri = this.normalizeUrl(kustoUri);
        if (kustoUri in this.cloudCache) {
            return this.cloudCache[kustoUri];
        }
        try {
            const response = await axios.get(this.getAuthMetadataEndpointFromClusterUri(kustoUri), {
                headers: {
                    "Cache-Control": "no-cache",
                    // Disable caching - it's being cached in memory (Service returns max-age).
                    // The original motivation for this is due to a CORS issue in Ibiza due to a dynamic subdomain.
                    // The first dynamic subdomain is attached to the cache and for some reason isn't invalidated
                    // when there is a new subdomain. It causes the request failure due to CORS.
                    // Example:
                    // Access to XMLHttpRequest at 'https://safrankecc.canadacentral.kusto.windows.net/v1/rest/auth/metadata' from origin
                    // 'https://sandbox-46-11.reactblade.portal.azure.net' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value
                    // 'https://sandbox-46-10.reactblade.portal.azure.net' that is not equal to the supplied origin.
                },
                maxRedirects: 0,
            });
            if (response.status === 200) {
                this.cloudCache[kustoUri] = response.data.AzureAD || this.defaultCloudInfo;
            }
            else {
                throw new Error(`Kusto returned an invalid cloud metadata response - ${response}`);
            }
        }
        catch (ex) {
            if (axios.isAxiosError(ex)) {
                // Axios library has a bug in browser, not propagating the status code, see: https://github.com/axios/axios/issues/5330
                if ((isNodeLike && ((_a = ex.response) === null || _a === void 0 ? void 0 : _a.status) === 404) || (!isNodeLike && (!ex.code || ex.code === AXIOS_ERR_NETWORK))) {
                    // For now as long not all proxies implement the metadata endpoint, if no endpoint exists return public cloud data
                    this.cloudCache[kustoUri] = this.defaultCloudInfo;
                }
                else {
                    throw new Error(`Failed to get cloud info for cluster ${kustoUri} - ${ex}`);
                }
            }
        }
        return this.cloudCache[kustoUri];
    }
    normalizeUrl(kustoUri) {
        const url = new URL(kustoUri);
        const urlString = url.toString();
        if (urlString.endsWith("/")) {
            return urlString.slice(0, urlString.length - 1);
        }
        return urlString;
    }
    getAuthMetadataEndpointFromClusterUri(kustoUri) {
        const url = new URL(kustoUri);
        // Returns endpoint URL in the form of https://<cluster>:port/v1/rest/auth/metadata
        return `${url.protocol}//${url.host}${this.METADATA_ENDPOINT}`;
    }
    static getAuthorityUri(cloudInfo, authorityId) {
        return cloudInfo.LoginEndpoint + "/" + (authorityId || "organizations");
    }
}
const cloudSettings = new CloudSettings();
export { cloudSettings as CloudSettings };
export default cloudSettings;
//# sourceMappingURL=cloudSettings.js.map