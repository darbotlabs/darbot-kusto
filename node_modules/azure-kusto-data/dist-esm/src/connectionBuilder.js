// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { KustoConnectionStringBuilderBase } from "./connectionBuilderBase.js";
/*
 * A builder for Kusto connection strings
 * For browsers use withUserPrompt or provide the token yourself using withTokenProvider
 */
export class KustoConnectionStringBuilder extends KustoConnectionStringBuilderBase {
    static withAadUserPasswordAuthentication(connectionString, userId, password, authorityId) {
        if (userId.trim().length === 0)
            throw new Error("Invalid user");
        if (password.trim().length === 0)
            throw new Error("Invalid password");
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.aadFederatedSecurity = true;
        kcsb.aadUserId = userId;
        kcsb.password = password;
        if (authorityId) {
            kcsb.authorityId = authorityId;
        }
        return kcsb;
    }
    static withAadApplicationKeyAuthentication(connectionString, aadAppId, appKey, authorityId) {
        if (aadAppId.trim().length === 0)
            throw new Error("Invalid app id");
        if (appKey.trim().length === 0)
            throw new Error("Invalid app key");
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.aadFederatedSecurity = true;
        kcsb.applicationClientId = aadAppId;
        kcsb.applicationKey = appKey;
        if (authorityId) {
            kcsb.authorityId = authorityId;
        }
        return kcsb;
    }
    static withAadApplicationCertificateAuthentication(connectionString, aadAppId, applicationCertificatePrivateKey, authorityId, applicationCertificateSendX5c, applicationCertificatePrivatePath) {
        if (aadAppId.trim().length === 0)
            throw new Error("Invalid app id");
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        if (!applicationCertificatePrivatePath) {
            if (!applicationCertificatePrivateKey) {
                throw new Error("withAadApplicationCertificateAuthentication should specify either a cert key or a path");
            }
            if (applicationCertificatePrivateKey.trim().length === 0)
                throw new Error("Invalid certificate key");
            kcsb.applicationCertificatePrivateKey = applicationCertificatePrivateKey;
        }
        else {
            if (applicationCertificatePrivateKey) {
                throw new Error("withAadApplicationCertificateAuthentication should specify either a cert key or a path");
            }
            kcsb.applicationCertificatePath = applicationCertificatePrivatePath;
        }
        kcsb.aadFederatedSecurity = true;
        kcsb.applicationClientId = aadAppId;
        kcsb.applicationCertificateSendX5c = applicationCertificateSendX5c;
        if (authorityId) {
            kcsb.authorityId = authorityId;
        }
        return kcsb;
    }
    static withAadDeviceAuthentication(connectionString, authorityId, deviceCodeCallback) {
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.aadFederatedSecurity = true;
        if (authorityId) {
            kcsb.authorityId = authorityId;
        }
        kcsb.deviceCodeCallback = deviceCodeCallback;
        kcsb.useDeviceCodeAuth = true;
        return kcsb;
    }
    static withAadManagedIdentities(connectionString, msiClientId, authorityId, timeoutMs) {
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.aadFederatedSecurity = true;
        if (authorityId) {
            kcsb.authorityId = authorityId;
        }
        kcsb.msiClientId = msiClientId;
        kcsb.timeoutMs = timeoutMs;
        kcsb.useManagedIdentityAuth = true;
        return kcsb;
    }
    static withSystemManagedIdentity(connectionString, authorityId, timeoutMs) {
        return this.withAadManagedIdentities(connectionString, undefined, authorityId, timeoutMs);
    }
    static withUserManagedIdentity(connectionString, msiClientId, authorityId, timeoutMs) {
        return this.withAadManagedIdentities(connectionString, msiClientId, authorityId, timeoutMs);
    }
    static withAzLoginIdentity(connectionString, authorityId, timeoutMs) {
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.aadFederatedSecurity = true;
        kcsb.useAzLoginAuth = true;
        if (authorityId) {
            kcsb.authorityId = authorityId;
        }
        kcsb.timeoutMs = timeoutMs;
        return kcsb;
    }
    static withAccessToken(connectionString, accessToken) {
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.aadFederatedSecurity = true;
        kcsb.accessToken = accessToken;
        return kcsb;
    }
    static withTokenProvider(connectionString, tokenProvider) {
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.aadFederatedSecurity = true;
        kcsb.tokenProvider = tokenProvider;
        return kcsb;
    }
    /**
     * Use InteractiveBrowserCredentialNodeOptions in Node.JS and InteractiveBrowserCredentialInBrowserOptions in browser
     * For browser cors issue: you need to visit your app registration and update the redirect URI you're using to the type spa (for "single page application").
     * See: https://github.com/Azure/azure-sdk-for-js/tree/main/sdk/identity/identity/test/manual/interactive-browser-credential
     */
    static withUserPrompt(connectionString, options, timeoutMs) {
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        const { tenantId, clientId } = options || {};
        if (clientId) {
            throw new Error("clientId should be empty as it is retrived from the service management endpoint");
        }
        kcsb.aadFederatedSecurity = true;
        kcsb.useUserPromptAuth = true;
        if (tenantId) {
            kcsb.authorityId = tenantId;
        }
        else if (options) {
            options.tenantId = kcsb.authorityId;
        }
        kcsb.timeoutMs = timeoutMs;
        return kcsb;
    }
    static withTokenCredential(connectionString, credential) {
        const kcsb = new KustoConnectionStringBuilder(connectionString);
        kcsb.tokenCredential = credential;
        return kcsb;
    }
    static fromExisting(other) {
        return Object.assign(new KustoConnectionStringBuilder(other.toString(false)), other);
    }
}
KustoConnectionStringBuilder.DefaultDatabaseName = "NetDefaultDB";
KustoConnectionStringBuilder.SecretReplacement = "****";
export default KustoConnectionStringBuilder;
//# sourceMappingURL=connectionBuilder.js.map