// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { ClientDetails } from "./clientDetails.js";
export const KeywordMapping = Object.freeze({
    dataSource: {
        mappedTo: "Data Source",
        validNames: ["data source", "addr", "address", "network address", "server"],
    },
    aadFederatedSecurity: {
        mappedTo: "AAD Federated Security",
        validNames: ["aad federated security", "federated security", "federated", "fed", "aadfed"],
        isBool: true,
    },
    initialCatalog: {
        mappedTo: "Initial Catalog",
        validNames: ["initial catalog", "database"],
    },
    aadUserId: {
        mappedTo: "AAD User ID",
        validNames: ["aad user id"],
    },
    password: {
        mappedTo: "Password",
        validNames: ["password", "pwd"],
        isSecret: true,
    },
    applicationClientId: {
        mappedTo: "Application Client Id",
        validNames: ["application client id", "appclientid"],
    },
    applicationKey: {
        mappedTo: "Application Key",
        validNames: ["application key", "appkey"],
        isSecret: true,
    },
    applicationCertificatePrivateKey: {
        mappedTo: "Application Certificate PrivateKey",
        validNames: ["Application Certificate PrivateKey"],
        isSecret: true,
    },
    applicationCertificateSendX5c: {
        mappedTo: "Application Certificate x5c",
        validNames: ["application certificate x5c", "Application Certificate Send Public Certificate", "Application Certificate SendX5c", "SendX5c"],
        isBool: true,
    },
    authorityId: {
        mappedTo: "Authority Id",
        validNames: ["authority id", "authorityid", "authority", "tenantid", "tenant", "tid"],
    },
});
const getPropName = (key) => {
    const _key = key.trim().toLowerCase();
    for (const keyword of Object.keys(KeywordMapping)) {
        const k = KeywordMapping[keyword];
        if (!k) {
            continue;
        }
        if (k.validNames.map((n) => n.trim().toLowerCase()).indexOf(_key) >= 0) {
            return [keyword, k];
        }
    }
    throw new Error("Failed to get prop: " + key);
};
export class KustoConnectionStringBuilderBase {
    constructor(connectionString) {
        var _a;
        this.authorityId = "organizations";
        this.applicationNameForTracing = null;
        this.userNameForTracing = null;
        if (connectionString.trim().length === 0)
            throw new Error("Missing connection string");
        if (connectionString.endsWith("/") || connectionString.endsWith("\\")) {
            connectionString = connectionString.slice(0, -1);
        }
        if (!!connectionString && connectionString.split(";")[0].indexOf("=") === -1) {
            connectionString = "Data Source=" + connectionString;
        }
        const params = connectionString.split(";");
        for (const item of params) {
            const kvp = item.split("=");
            const [mappingTypeName, mappingType] = getPropName(kvp[0]);
            if (mappingType.isBool) {
                this[mappingTypeName] = kvp[1].trim().toLowerCase() === "true";
            }
            else {
                this[mappingTypeName] = (_a = kvp[1]) === null || _a === void 0 ? void 0 : _a.trim();
            }
        }
        if (!this.initialCatalog) {
            this.initialCatalog = KustoConnectionStringBuilderBase.DefaultDatabaseName;
        }
    }
    clientDetails() {
        return new ClientDetails(this.applicationNameForTracing, this.userNameForTracing);
    }
    /**
     * Sets the connector details for tracing purposes.
     *
     * @param name  The name of the connector
     * @param version  The version of the connector
     * @param appName The name of the containing application
     * @param appVersion The version of the containing application
     * @param sendUser Whether to send the username
     * @param overrideUser Override the username ( if sendUser is True )
     * @param additionalFields Additional fields to add to the header
     */
    setConnectorDetails(name, version, appName, appVersion, sendUser = false, overrideUser, additionalFields) {
        const clientDetails = ClientDetails.setConnectorDetails(name, version, appName, appVersion, sendUser, overrideUser, additionalFields);
        this.applicationNameForTracing = clientDetails.applicationNameForTracing;
        this.userNameForTracing = clientDetails.userNameForTracing;
    }
    toString(removeSecrets = true) {
        return Object.entries(KeywordMapping)
            .map(([key, mappingType]) => {
            const value = this[key];
            if (!mappingType || value === undefined) {
                return "";
            }
            if (mappingType.isSecret && removeSecrets) {
                return `${mappingType.mappedTo}=${KustoConnectionStringBuilderBase.SecretReplacement}`;
            }
            return `${mappingType.mappedTo}=${value.toString()}`;
        })
            .filter((x) => x !== "")
            .join(";");
    }
}
KustoConnectionStringBuilderBase.DefaultDatabaseName = "NetDefaultDB";
KustoConnectionStringBuilderBase.SecretReplacement = "****";
export default KustoConnectionStringBuilderBase;
//# sourceMappingURL=connectionBuilderBase.js.map