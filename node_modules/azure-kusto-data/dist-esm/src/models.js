// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { parseKustoTimestampToMillis } from "./timeUtils.js";
export var WellKnownDataSet;
(function (WellKnownDataSet) {
    WellKnownDataSet["PrimaryResult"] = "PrimaryResult";
    WellKnownDataSet["QueryCompletionInformation"] = "QueryCompletionInformation";
    WellKnownDataSet["TableOfContents"] = "TableOfContents";
    WellKnownDataSet["QueryProperties"] = "QueryProperties";
})(WellKnownDataSet || (WellKnownDataSet = {}));
const defaultDatetimeParser = (t) => (t ? new Date(t) : null);
const defaultTimespanParser = parseKustoTimestampToMillis;
/**
 * Represents a Kusto result row.
 * Use `dateTimeParser` and `timeSpanParser` to customize the parsing of the `datetime` and `timespan` types.
 * By default, `datetime` is parsed to a `Date` object and `timespan` is parsed to a number representing the number of milliseconds, as returned by subtracting two `Date` objects.
 */
export class KustoResultRow {
    constructor(columns, row, dateTimeParser = defaultDatetimeParser, timeSpanParser = defaultTimespanParser) {
        this.columns = columns.sort((a, b) => a.ordinal - b.ordinal);
        this.raw = row;
        for (const col of this.columns) {
            if (col.name == null) {
                continue;
            }
            let value = row[col.ordinal];
            if (col.type != null) {
                switch (col.type.toLowerCase()) {
                    case "datetime":
                        value = dateTimeParser(value);
                        break;
                    case "timespan":
                        value = timeSpanParser(value);
                        break;
                }
                this[col.name] = row[col.ordinal];
            }
            this[col.name] = value;
        }
    }
    *values() {
        for (let i = 0; i < this.columns.length; i++) {
            yield this.raw[i];
        }
    }
    getValueAt(index) {
        return this[this.columns[index].name];
    }
    /**
     * @deprecated use the compliant toJSON() instead
     */
    toJson() {
        return this.toJSON();
    }
    toJSON() {
        const obj = {};
        for (const col of this.columns) {
            obj[col.name] = this[col.name];
        }
        return obj;
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
export class KustoResultColumn {
    constructor(columnObj, ordinal) {
        var _a, _b;
        this.name = (_a = columnObj.ColumnName) !== null && _a !== void 0 ? _a : null;
        // TODO: should validate type? should coarse value to type?
        this.type = (_b = (columnObj.ColumnType || columnObj.DateType)) !== null && _b !== void 0 ? _b : null;
        this.ordinal = ordinal;
    }
}
export class KustoResultTable {
    constructor(tableObj) {
        this._dateTimeParser = defaultDatetimeParser;
        this._timeSpanParser = defaultTimespanParser;
        this.name = tableObj.TableName;
        if (tableObj.TableId !== undefined) {
            this.id = tableObj.TableId;
        }
        if (tableObj.TableKind) {
            this.kind = tableObj.TableKind;
        }
        this.columns = tableObj.Columns.map((item, index) => new KustoResultColumn(item, index));
        this._rows = tableObj.Rows;
        if (this._rows && this._rows.length > 0) {
            for (let i = 0; i < tableObj.Rows.length; i++) {
                Object.defineProperty(this, i, { get: () => new KustoResultRow(this.columns, this._rows[i]) });
            }
        }
    }
    get timeSpanParser() {
        return this._timeSpanParser;
    }
    set timeSpanParser(value) {
        this._timeSpanParser = value;
    }
    get dateTimeParser() {
        return this._dateTimeParser;
    }
    set dateTimeParser(value) {
        this._dateTimeParser = value;
    }
    *rows() {
        for (const row of this._rows) {
            yield new KustoResultRow(this.columns, row, this._dateTimeParser, this._timeSpanParser);
        }
    }
    /**
     * @deprecated use the compliant toJSON() instead
     */
    toJson() {
        return this.toJSON();
    }
    toJSON() {
        const table = {
            name: this.name,
            data: [],
        };
        for (const row of this.rows()) {
            table.data.push(row.toJSON());
        }
        return table;
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
//# sourceMappingURL=models.js.map