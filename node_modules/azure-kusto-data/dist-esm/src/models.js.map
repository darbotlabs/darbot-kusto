{"version":3,"file":"models.js","sourceRoot":"","sources":["../../src/models.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { parseKustoTimestampToMillis } from \"./timeUtils.js\";\n\nexport enum WellKnownDataSet {\n    PrimaryResult = \"PrimaryResult\",\n    QueryCompletionInformation = \"QueryCompletionInformation\",\n    TableOfContents = \"TableOfContents\",\n    QueryProperties = \"QueryProperties\",\n}\n\ntype DateTimeParser = (value: string | null) => any;\ntype TimeSpanParser = (value: string | null) => any;\n\nconst defaultDatetimeParser: DateTimeParser = (t: string | null) => (t ? new Date(t) : null);\nconst defaultTimespanParser: TimeSpanParser = parseKustoTimestampToMillis;\n\nexport interface Table {\n    TableKind?: string;\n    TableName: string;\n    TableId?: number;\n    Columns: Column[];\n    Rows: any[][];\n}\n\ninterface Column {\n    ColumnName: string;\n    ColumnType?: string;\n    DateType?: string;\n}\n\n/**\n * Represents a Kusto result row.\n * Use `dateTimeParser` and `timeSpanParser` to customize the parsing of the `datetime` and `timespan` types.\n * By default, `datetime` is parsed to a `Date` object and `timespan` is parsed to a number representing the number of milliseconds, as returned by subtracting two `Date` objects.\n */\nexport class KustoResultRow {\n    columns: KustoResultColumn[];\n    raw: { [ord: number]: any };\n\n    [column: string]: any;\n\n    constructor(\n        columns: KustoResultColumn[],\n        row: { [ord: number]: any },\n        dateTimeParser: DateTimeParser = defaultDatetimeParser,\n        timeSpanParser: TimeSpanParser = defaultTimespanParser,\n    ) {\n        this.columns = columns.sort((a, b) => a.ordinal - b.ordinal);\n        this.raw = row;\n\n        for (const col of this.columns) {\n            if (col.name == null) {\n                continue;\n            }\n            let value = row[col.ordinal];\n\n            if (col.type != null) {\n                switch (col.type.toLowerCase()) {\n                    case \"datetime\":\n                        value = dateTimeParser(value);\n                        break;\n                    case \"timespan\":\n                        value = timeSpanParser(value);\n                        break;\n                }\n                this[col.name] = row[col.ordinal];\n            }\n\n            this[col.name] = value;\n        }\n    }\n\n    *values() {\n        for (let i = 0; i < this.columns.length; i++) {\n            yield this.raw[i];\n        }\n    }\n\n    getValueAt(index: number) {\n        return this[this.columns[index].name as string];\n    }\n\n    /**\n     * @deprecated use the compliant toJSON() instead\n     */\n    toJson() {\n        return this.toJSON();\n    }\n\n    toJSON<T = Record<string, any>>(): T {\n        const obj: Record<string, any> = {};\n\n        for (const col of this.columns) {\n            obj[col.name as string] = this[col.name as string];\n        }\n\n        return obj as T;\n    }\n\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n}\n\nexport class KustoResultColumn {\n    name: string | null;\n    type: string | null;\n    ordinal: number;\n\n    constructor(columnObj: { ColumnName?: string; ColumnType?: string; DateType?: string }, ordinal: number) {\n        this.name = columnObj.ColumnName ?? null;\n        // TODO: should validate type? should coarse value to type?\n        this.type = (columnObj.ColumnType || columnObj.DateType) ?? null;\n        this.ordinal = ordinal;\n    }\n}\n\nexport class KustoResultTable {\n    name: string;\n    id?: number;\n    kind?: string;\n    columns: KustoResultColumn[];\n    readonly _rows: any[];\n    private _dateTimeParser: DateTimeParser = defaultDatetimeParser;\n    private _timeSpanParser: TimeSpanParser = defaultTimespanParser;\n\n    [row: number]: any;\n\n    constructor(tableObj: Table) {\n        this.name = tableObj.TableName;\n        if (tableObj.TableId !== undefined) {\n            this.id = tableObj.TableId;\n        }\n\n        if (tableObj.TableKind) {\n            this.kind = tableObj.TableKind;\n        }\n\n        this.columns = tableObj.Columns.map((item, index) => new KustoResultColumn(item, index));\n        this._rows = tableObj.Rows;\n\n        if (this._rows && this._rows.length > 0) {\n            for (let i = 0; i < tableObj.Rows.length; i++) {\n                Object.defineProperty(this, i, { get: () => new KustoResultRow(this.columns, this._rows[i]) });\n            }\n        }\n    }\n\n    get timeSpanParser(): TimeSpanParser {\n        return this._timeSpanParser;\n    }\n\n    set timeSpanParser(value: TimeSpanParser) {\n        this._timeSpanParser = value;\n    }\n    get dateTimeParser(): DateTimeParser {\n        return this._dateTimeParser;\n    }\n\n    set dateTimeParser(value: DateTimeParser) {\n        this._dateTimeParser = value;\n    }\n\n    *rows() {\n        for (const row of this._rows) {\n            yield new KustoResultRow(this.columns, row, this._dateTimeParser, this._timeSpanParser);\n        }\n    }\n\n    /**\n     * @deprecated use the compliant toJSON() instead\n     */\n    toJson() {\n        return this.toJSON();\n    }\n\n    toJSON<T = Record<string, any>>(): {\n        name: string;\n        data: T[];\n    } {\n        const table: {\n            name: string;\n            data: T[];\n        } = {\n            name: this.name,\n            data: [],\n        };\n        for (const row of this.rows()) {\n            table.data.push(row.toJSON<T>());\n        }\n\n        return table;\n    }\n\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n}\n"]}